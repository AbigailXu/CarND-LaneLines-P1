# **Finding Lane Lines on the Road** 

## Writeup

---

**Finding Lane Lines on the Road**

The goals / steps of this project are the following:
* Make a pipeline that finds lane lines on the road
* Reflect on your work in a written report


[//]: # (Image References)

[img1]: ./writeup_images/1.png
[img2]: ./writeup_images/2.png
[img3]: ./writeup_images/3.png
[img4]: ./writeup_images/4.png
[img5]: ./writeup_images/5.png
[img6]: ./writeup_images/6.png
[img7]: ./writeup_images/7.png
[img8]: ./writeup_images/8.png
---

### Reflection

### 1. Describe your pipeline. As part of the description, explain how you modified the draw_lines() function.

My pipeline consisted of 8 steps. 

1. First, I convert the smoothed image from RGB to HSV. I defined thresholds for white lines (white_thresh) and yellow lines (yellow_thresh) through experimenting, and used the thresholds to extract the lines in the image through bitwise operations to get an image (color_threshed) composed of only white/yellow objects. 

![alt text][img1]

2. I convert the color-threshed image (color_threshed) to grayscale (color_threshed_gray) using function grayscale().

![alt text][img2]

3. Then, perform smoothing (gaussian_blur), it helps to reduces noise. 

![alt text][img3]

4. Then, I used canny() to extract the canny edge (canny_edge) of the grayscaled image (color_threshed_gray).

![alt text][img4]

5. I selected a region of interest (roi) in the image, which is expected to be the region in front of a car. To do this, I defined a trapezoid and used region_of_interest() function to extract this trapezoid region from canny_edge image. This generates an image (roi) containing only the canny edges inside the region of interest. They are expected to be on the lane lines in front of a car.

![alt text][img5]

6. I converted the canny edge image (roi) to an image of hough lines and an array of lines, using hough_lines(). Stored them in (line_segment, lines)

![alt text][img6]

7. I classified the lines generated by hough_lines into left and right parts. Specifically, I separate them into left_x, left_y, right_x, right_y for future convenience in Linear Regression.

![alt text][img7]

8. I implemented Linear Regression on the (x,y) points on the left and right respectively, and got the coefficients for the lines. Then, I used the coefficients to estimate the top and bottom points of the lines (that may be missing, such as when there's a dotted line). I draw left/right lines by connecting the top and bottom points in the left and right respectively. Finally, return 2 images with lane-markings, one without Linear Regression (just using line_segment generated by hough_lines), and one with Linear Regression.

![alt text][img8]

Now that findLane() is complete, I call it with image input to get one output without Linear Regression, and one with Linear Regression


### 2. Identify potential shortcomings with your current pipeline

One potential shortcoming would be what would happen when the vehicle is required to detect the curves in a lane. Since the current implementation uses linear regression, it cannot produce a curved marking.

Another shortcoming could be, the line color threshold is limited to a specific range of environments. Since it is manually defined, the threshold may not work under different weather, light conditions, etc.

In real life, a car needs to switch lanes. Thus a third shortcoming would be, the current pipeline only processes the lane in front of the car, but not the other lanes beside it. As a result, the car cannot switch lanes.


### 3. Suggest possible improvements to your pipeline

A possible improvement would be to use non-linear regression, this allows the pipeline to draw the curved lines of a curve lane.

Another potential improvement could be to use automatic thresholding, using the Otsu method.

One other potential improvement is to expand the region of interest and detect the lines on other lanes. However, expanding the region of interest means that the pipeline needs to handle more noise.

